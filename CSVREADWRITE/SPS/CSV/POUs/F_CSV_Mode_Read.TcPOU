<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="F_CSV_Mode_Read" Id="{f9b1d849-991e-4a69-97de-12dd84c23f95}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK F_CSV_Mode_Read
VAR_INPUT
	bRead			: BOOL := FALSE;(* Rising edge starts program execution *)
END_VAR
VAR_OUTPUT
	bBusy			: BOOL;
	bError			: BOOL;
	nErrId			: UDINT;
END_VAR
VAR
	sNetId			: T_AmsNetId := '';	(* TwinCAT system network address *)
	sFileName		: T_MaxString := 'C:\Temp\CSVDateien.csv';(* CSV source file path and name *)
	sCSVLine		: T_MaxString := '';(* Single CSV text line (row, record), we are using string as record buffer (your are able to see read fields)  *)
	sCSVField		: T_MaxString := '';(* Single CSV field value (column, record field) *)
	nRow	 		: UDINT 	:= 0;(* Row number (record) *)
	nColumn			: UDINT 	:= 0;(* Column number (record field) *)
	hFile			: UINT		:= 0;(* File handle of the source file *)
	step			: DWORD 	:= 0;
	fbFileOpen		: FB_FileOpen;(* Opens file *)
	fbFileClose		: FB_FileClose;(* Closes file *)
	fbFileGets		: FB_FileGets;(* Reads one record (line) *)
	fbReader		: FB_CSVMemBufferReader;(* Helper function block used to parse CSV data bytes (single record line) *)
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE step OF
	0:	(* Wait for rising edge at bRead variable *)
		IF bRead THEN
			bRead 	:= FALSE;
			bBusy 		:= TRUE;
			bError		:= FALSE;
			nErrId		:= 0;
			hFile		:= 0;
			nRow	 	:= 0;
			nColumn	:= 0;
			MEMSET( ADR( Database_STRING ), 0, SIZEOF( Database_STRING ) );
			step 		:= 1;
		END_IF

	1:	(* Open source file *)
		fbFileOpen(  bExecute := FALSE  );
		fbFileOpen( 	sNetId := sNetId, sPathName := sFileName, nMode := FOPEN_MODEREAD OR FOPEN_MODETEXT,(* Open file in TEXT mode! *)
						ePath := PATH_GENERIC, bExecute := TRUE );
		step := 2;

	2:(* Wait until open not busy *)
		fbFileOpen( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
		IF NOT fbFileOpen.bBusy THEN
			IF NOT fbFileOpen.bError THEN
				step := 3;
			ELSE(* Error: file not found? *)
				step := 100;
			END_IF
		END_IF

	3:	(* Read single line (record) *)
		fbFileGets( bExecute := FALSE );
		fbFileGets( sNetId := sNetId, hFile := hFile, bExecute := TRUE );
		step := 4;

	4:(* Wait until read not busy *)
		fbFileGets( bExecute := FALSE, bError => bError, nErrID => nErrID, sLine => sCSVLine );
		IF NOT fbFileGets.bBusy THEN
			IF NOT fbFileGets.bError THEN
				IF fbFileGets.bEOF THEN
					step := 10;(* End of file reached => Close source file *)
				ELSE

					(* FB_FileGets returns text line without the CR (carriage return) character.
					We have to restore the CR character (replace the $L character with $R$L characters) *)
					IF RIGHT( sCSVLine, 1 ) = '$L' THEN
						sCSVLine := REPLACE( sCSVLine, '$R$L', 2, LEN( sCSVLine ) );
					END_IF

					step := 5;
				END_IF
			ELSE(* Error *)
				step := 100;
			END_IF
		END_IF

	5:(* Parse single line (record) *)
		fbReader.eCmd := eEnumCmd_First;(* Read first field value *)
		REPEAT
			fbReader( pBuffer := ADR( sCSVLine ), cbBuffer := SIZEOF( sCSVLine ), getValue =>sCSVField );
			IF fbReader.bOk THEN
				fbReader.eCmd := eEnumCmd_Next;(* Read next field value *)

				IF ( nRow <= MAX_CSV_ROWS ) THEN
					IF ( nColumn <= MAX_CSV_COLUMNS ) THEN
						Database_STRING[nRow, nColumn] := CSVFIELD_TO_STRING( sCSVField, FALSE );(* TODO: Save or use the field value in your application *)
					END_IF
				END_IF

				nColumn := nColumn + 1;(* Increment number of read columns *)
				IF fbReader.bCRLF THEN(* CRLF == TRUE => End of reacord reached *)
					nRow 		:= nRow + 1;(* Increment number of read records *)
					nColumn 	:= 0;(* Reset number of columns *)
				END_IF

			ELSE(* Error: End of record reached or all fields read *)
				step := 3;(* Try to read next line *)
			END_IF
		UNTIL NOT fbReader.bOk
		END_REPEAT

	10:	(* Close source file *)
		fbFileClose( bExecute := FALSE );
		fbFileClose( sNetId := sNetId, hFile := hFile, bExecute := TRUE );
		step := 11;

	11:(* Wait until close not busy *)
		fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF ( NOT fbFileClose.bBusy ) THEN
			hFile := 0;
			step := 100;
		END_IF

	100: (* Error or ready step => cleanup *)
		IF ( hFile <> 0 ) THEN
			step := 10; (* Close the source file *)
		ELSE
			bBusy := FALSE;
			step := 0;	(* Ready *)
		END_IF

END_CASE

(*
IF step=10 THEN
	
Database_DINT[0,0]:=STRING_TO_DINT(Database_String[0,0]);
Database_DINT[0,1]:=STRING_TO_DINT(Database_String[0,1]);
Database_DINT[0,2]:=STRING_TO_DINT(Database_String[0,2]);
Database_DINT[0,3]:=STRING_TO_DINT(Database_String[0,3]);
Database_DINT[0,4]:=STRING_TO_DINT(Database_String[0,4]);
Database_DINT[0,5]:=STRING_TO_DINT(Database_String[0,5]);
Database_DINT[1,0]:=STRING_TO_DINT(Database_String[1,0]);
Database_DINT[1,1]:=STRING_TO_DINT(Database_String[1,1]);
Database_DINT[1,2]:=STRING_TO_DINT(Database_String[1,2]);
Database_DINT[1,3]:=STRING_TO_DINT(Database_String[1,3]);
Database_DINT[1,4]:=STRING_TO_DINT(Database_String[1,4]);
Database_DINT[1,5]:=STRING_TO_DINT(Database_String[1,5]);
Database_DINT[2,0]:=STRING_TO_DINT(Database_String[2,0]);
Database_DINT[2,1]:=STRING_TO_DINT(Database_String[2,1]);
Database_DINT[2,2]:=STRING_TO_DINT(Database_String[2,2]);
Database_DINT[2,3]:=STRING_TO_DINT(Database_String[2,3]);
Database_DINT[2,4]:=STRING_TO_DINT(Database_String[2,4]);
Database_DINT[2,5]:=STRING_TO_DINT(Database_String[2,5]);
Database_DINT[3,0]:=STRING_TO_DINT(Database_String[3,0]);
Database_DINT[3,1]:=STRING_TO_DINT(Database_String[3,1]);
Database_DINT[3,2]:=STRING_TO_DINT(Database_String[3,2]);
Database_DINT[3,3]:=STRING_TO_DINT(Database_String[3,3]);
Database_DINT[3,4]:=STRING_TO_DINT(Database_String[3,4]);
Database_DINT[3,5]:=STRING_TO_DINT(Database_String[3,5]);
Database_DINT[4,0]:=STRING_TO_DINT(Database_String[4,0]);
Database_DINT[4,1]:=STRING_TO_DINT(Database_String[4,1]);
Database_DINT[4,2]:=STRING_TO_DINT(Database_String[4,2]);
Database_DINT[4,3]:=STRING_TO_DINT(Database_String[4,3]);
Database_DINT[4,4]:=STRING_TO_DINT(Database_String[4,4]);
Database_DINT[4,5]:=STRING_TO_DINT(Database_String[4,5]);
Database_DINT[5,0]:=STRING_TO_DINT(Database_String[5,0]);
Database_DINT[5,1]:=STRING_TO_DINT(Database_String[5,1]);
Database_DINT[5,2]:=STRING_TO_DINT(Database_String[5,2]);
Database_DINT[5,3]:=STRING_TO_DINT(Database_String[5,3]);
Database_DINT[5,4]:=STRING_TO_DINT(Database_String[5,4]);
Database_DINT[5,5]:=STRING_TO_DINT(Database_String[5,5]);

END_IF

*)]]></ST>
    </Implementation>
    <LineIds Name="F_CSV_Mode_Read">
      <LineId Id="26" Count="143" />
      <LineId Id="176" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>